#include <stdio.h>
#include <math.h>

// sigmoid
float sigmoid(float x) {
    return 1.0f / (1.0f + expf(-x));
}
float d_sigmoid(float x) {
    float s = sigmoid(x);
    return s * (1.0f - s);
}

// relu
float relu(float x) {
    return (x > 0) ? x : 0;
}
float d_relu(float x) {
    return (x > 0) ? 1.0f : 0.0f;
}

// leaky relu
float leaky_relu(float x) {
    return (x > 0) ? x : 0.01f * x;
}
float d_leaky_relu(float x) {
    return (x > 0) ? 1.0f : 0.01f;
}

// tanh
float my_tanh(float x) {
    float a = expf(x);
    float b = expf(-x);
    return (a - b) / (a + b);
}
float d_my_tanh(float x) {
    float t = my_tanh(x);
    return 1.0f - (t * t);
}

// softsign
float softsign(float x) {
    return x / (1.0f + fabsf(x));
}
float d_softsign(float x) {
    float d = 1.0f + fabsf(x);
    return 1.0f / (d * d);
}

// elu
float elu(float x, float alpha) {
    return (x >= 0) ? x : alpha * (expf(x) - 1.0f);
}
float d_elu(float x, float alpha) {
    return (x >= 0) ? 1.0f : alpha * expf(x);
}

// softplus
float softplus(float x) {
    return logf(1.0f + expf(x));
}
float d_softplus(float x) {
    return sigmoid(x);
}

// swish
float swish(float x) {
    return x * sigmoid(x);
}
float d_swish(float x) {
    float s = sigmoid(x);
    return s + x * s * (1.0f - s);
}

// binary step
float binary_step(float x) {
    return (x >= 0) ? 1.0f : 0.0f;
}
float d_binary_step(float x) {
    return 0.0f;
}

// linear
float linear(float x) {
    return x;
}
float d_linear(float x) {
    return 1.0f;
}

// mish
float mish(float x) {
    return x * my_tanh(softplus(x));
}
float d_mish(float x) {
    float sp = softplus(x);
    float t = my_tanh(sp);
    float s = sigmoid(x);
    return t + x * (1.0f - t * t) * s;
}

// hard-sigmoid
float hard_sigmoid(float x) {
    float r = (0.2f * x) + 0.5f;
    if (r < 0) r = 0;
    if (r > 1) r = 1;
    return r;
}
float d_hard_sigmoid(float x) {
    return (x > -2.5f && x < 2.5f) ? 0.2f : 0.0f;
}

// hard-swish
float hard_swish(float x) {
    return x * hard_sigmoid(x);
}
float d_hard_swish(float x) {
    float hs = hard_sigmoid(x);
    float d_hs = d_hard_sigmoid(x);
    return (hs + x * d_hs);
}

// softmax
// void softmax(float arr[], float out[], int n) {
//     float sum = 0;
//     for(int i = 0; i < n; i++)
//         sum += expf(arr[i]);
//     for(int i = 0; i < n; i++)
//         out[i] = expf(arr[i]) / sum;
// }

float mse(float actual[], float predicted[], int n) {
    float sum_squared_error = 0.0;
    for (int i = 0; i < n; i++) {
        double error = actual[i] - predicted[i];

        sum_squared_error += pow(error, 2);
    }

    return sum_squared_error / n;
}

void mse_derivative(double y[], double y_hat[], double grad[], int n) {
    // derivative: (2/n) * (y_hat[i] - y[i])
    double factor = 2.0 / n;

    for (int i = 0; i < n; i++) {
        grad[i] = factor * (y_hat[i] - y[i]);
    }
}


int main() {
    return 0;
}
