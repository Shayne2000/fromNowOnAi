#include <stdio.h>
#include <math.h>

// ---------------- Activation functions ----------------
float linear(float x) { return x; }
float sigmoid(float x) { return 1.0f / (1.0f + expf(-x)); }
float relu(float x) { return (x>0)? x:0; }
float leaky_relu(float x) { return (x>0)? x:0.01f*x; }
float tanh_act(float x) { return tanhf(x); }
float softsign(float x) { return x / (1.0f + fabsf(x)); }
float elu(float x) { return (x>=0)? x:expf(x)-1.0f; }
float softplus(float x) { return log1pf(expf(x)); }
float swish(float x) { return x * sigmoid(x); }
float mish(float x) { return x * tanhf(softplus(x)); }
float binary_step(float x) { return (x>=0)?1.0f:0.0f; }
float hard_sigmoid(float x) { float r=0.2f*x+0.5f; if(r<0) r=0; if(r>1) r=1; return r; }
float hard_swish(float x) { return x * hard_sigmoid(x); }

// ---------------- Derivatives ----------------
float d_linear(float x) { return 1; }
float d_sigmoid(float x) { float s=sigmoid(x); return s*(1-s); }
float d_relu(float x) { return (x>0)?1:0; }
float d_leaky_relu(float x) { return (x>0)?1:0.01f; }
float d_tanh(float x) { float t=tanhf(x); return 1-t*t; }
float d_softsign(float x) { float denom=1+fabsf(x); return 1/(denom*denom); }
float d_elu(float x) { return (x>=0)?1:expf(x); }
float d_softplus(float x) { return 1/(1+expf(-x)); }
float d_swish(float x) { float s=sigmoid(x); return s + x*s*(1-s); }
float d_mish(float x) { float sp=log1pf(expf(x)); float t=tanhf(sp); float ds=1/(1+expf(-x)); return t + x*ds*(1-t*t); }
float d_binary_step(float x) { return 0; }
float d_hard_sigmoid(float x) { return (x>-2.5f && x<2.5f)?0.2f:0; }
float d_hard_swish(float x) { float r=(x>-2.5f && x<2.5f)?0.2f:0; return r*x + hard_sigmoid(x); }

// ---------------- List of functions ----------------
#define NUM_ACT 13
const char* activation_names[NUM_ACT] = {
    "linear","sigmoid","relu","leaky_relu","tanh",
    "softsign","elu","softplus","swish","mish",
    "binary_step","hard_sigmoid","hard_swish"
};

float (*activations[NUM_ACT])(float) = {
    linear,sigmoid,relu,leaky_relu,tanh_act,softsign,elu,
    softplus,swish,mish,binary_step,hard_sigmoid,hard_swish
};

float (*derivatives[NUM_ACT])(float) = {
    d_linear,d_sigmoid,d_relu,d_leaky_relu,d_tanh,d_softsign,d_elu,
    d_softplus,d_swish,d_mish,d_binary_step,d_hard_sigmoid,d_hard_swish
};

int main() {
    int n;
    printf("How many activation functions do you want to choose? ");
    scanf("%d", &n);

    if(n <= 0){
        printf("Invalid number!\n");
        return 1;
    }

    // pointer array สำหรับเก็บ activation function ของแต่ละ choice
    float* chosen_activation[n];
    const char* chosen_name[n];

    int choice;
    for(int i=0; i<n; i++){
        // ---------------- Show list ----------------
        printf("\nChoose activation function #%d:\n", i+1);
        for(int j=0; j<NUM_ACT; j++){
            printf("%2d) %s\n", j+1, activation_names[j]);
        }

        printf("Enter number: ");
        scanf("%d", &choice);

        if(choice >=1 && choice <= NUM_ACT){
            int index = choice-1;
            chosen_activation[i] = activations[index];
            chosen_name[i] = activation_names[index];
            printf("You chose: %s\n", chosen_name[i]);
        } else {
            printf("Invalid choice! Try again.\n");
            i--; // เลือกผิดให้วนรอบนี้ใหม่
        }
    }

    // ---------------- Show all choices ----------------
    printf("\nAll chosen activation functions:\n");
    for(int i=0;i<n;i++){
        printf("Choice %d: %s\n", i+1, chosen_name[i]);
    }

    // ---------------- Example usage ----------------
    float x = 0.5f;
    printf("\nExample activation outputs for x=%.2f:\n", x);
    for(int i=0;i<n;i++){
        int index = 0;
        // หา index ของ activation เพื่อเรียก derivative
        for(int j=0;j<NUM_ACT;j++){
            if(chosen_activation[i] == activations[j]){
                index = j;
                break;
            }
        }
        printf("%d) %s: %.4f (derivative: %.4f)\n",
            i+1, chosen_name[i],
            chosen_activation[i](x),
            derivatives[index](x));
    }

    return 0;
}
